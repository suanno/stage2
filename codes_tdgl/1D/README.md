# TUTORIAL: solve TDGL
- Execute "flatinit" to have a flat initial state or "datainit" to have a random state very close to $u=0$ .
        
        gcc flatinit.c -o .bin/flatinit
        ./flatinit <lattice points> <flat value>

        gcc datainit.c -o .bin/datainit
        ./datainit <lattice points>
    Both file will create a "fileinit.dat" which has the _seed_ and the _number of lattice points_ in the first line.
    In the following lines it contains the $u(x,0)$ values.
    **NOTE:** You have to select **$N$ even** to use "tdgl", because the FFT algotithm used assumes that $N$ is even!!!

- Execute "tdglfd", it evolves the state with **Explicit euler** (_fd_ stands for _finite difference_) for a time $tspan$ (with discrete time step $dt$) with varying in time $C(t) = \bar{C} + A\sin(2\pi t/T)$ (where we adopt the convention $T/2 = -1$ means that C is costant and $C=A$)
        
        gcc tdglfd.c -o .bin/tdglfd -lm
        ./tdglfd <tspan> <A> <T> <Caverage> <dt>
        

    - If the initial state is not smooth (it was generated by "datainit") you _have to_ execute this code _at least for a short period_, because "tdgl" needs a smooth initial state [cit. TUNG]
    - While if the initial state is flat, then you don't need to evolve the system with this code. Anyway you still need to execute it for a timespan equal to zero, in order to create the file "tdgl_result.dat" that _is necessary_ for running "tdgl".

    The code creates a file "tdgl_result.dat" that contains in the first row
    - the number of lattice points N
    - the time $t$ of the state (the following lines contain the state $(x, u(x,t))$)
    - dx and dt integration steps
    - the seed (this information can be used when reading the data to label a plot or to perform again the same evolution for _troubleshooting_)
    - the amplitude $A$ and the half-period $T/2$ of the $C(t)$ evolution
    
- Execute "tdgl", this code evolves **progressively** the state in Fourier space. The syntax is the same of "tdglfd"

        gcc tdgl.c -o .bin/tdglfd -lfftw3 -lm
        ./tdgl <tspan> <A> <T> <Caverage> <dt>
    It needs the existance of the file "tdgl_result.dat" to be run and the initial state must be smooth (because a sinusoidal decomposition must make sense).

    It **updates** the state recorded in "tdgl_result.dat", updating even the time $t$ of the state.
    The new values of $C(t)$ in time and of the space average of $u(x,t)$ are **appended** in the files "fileCout.dat" and "fileAveout.dat", so those files contains information about **the whole** simulation (from $t=0$).

    The files "fileCout.dat" and "fileAveout.dat" are emptied when "tdglfd" or "flatinit" or "datainit" are executed and the file "fileinit.dat" is overwritten.

## Saving
You can execute "save.ipynb" to save the results of the evolution (see the notebook for more info).

**ATTENTION**: Now i commented some lines of save.ipynb and added some new. Now it works for "rapid plot" but not for "flat plot" because i add a new line at the top of the file.

You **have to FIX** this incompatibility!

## Plotting
- To plot the actual state of the system, you can use "plot_state.ipynb" that even saves the plot in a directory with the _seed_ name, while the name of the image is the _time t_ of the state.

- To plot the space average of $u(x,t)$ at times $t=nT$, where $T$ is the period of $C(t)$, you can use "flat plots saves.ipynb", that uses the saved data with "save.ipynb".

- Rapid plot: Are two files 
    - rapid plot.ipynb: Plots the content of fileAveout.dat and tdgl_results.dat (of the **last** simulation you run without the need of specifying the name of the saves' file)
    - rapid multiplot.ipynb: You specify the name of the folder containing the data you want to plot (Space average of $u$ data) and plots on the same canvas all the curves. The label of each curve is the **first line** of the corresponding fileAveout.dat, that **is added editing save.ipynb**